import { CalendarIcon } from "lucide-react";
import Calendar from "calendar.io";
import { EventModal } from "./EventModal";
import { SettingsPanel } from "./settings/SettingsPanel";
import { useTranslation } from "../context/TranslationContext";
import { useHolidays } from "../context/HolidayContext";
import { Event } from "../types/event";
import { User } from "../types/user";
import { format } from "date-fns";
  
export default function CalendarComponent() {
  if (!currentUser) {
    return (
      <div className="min-h-screen flex items-center justify-center text-red-600">
        {t('errors.somethingWentWrong')}
      </div>
    );
  }

  const calendarEvents = events.map(event => {
    const colleagueSettings = currentUser?.settings?.colleagues?.[event.userId];
    const backgroundColor = colleagueSettings?.color || "#3788d8";
    const initials = colleagueSettings?.initials || "";
    let title = event.title || getEventTypeLabel(event.type, event.status);
    if (initials && event.userId !== currentUser.id) {
      title = `${initials}: ${title}`;
    }

    return {
      id: event.id,
      title,
      start: event.date,
      borderColor: backgroundColor,
      textColor: getTextColor(backgroundColor),
      isHoliday: true
    };
  });

  // Add availability as background events
  const availabilityEvents = Object.entries(availabilityData).flatMap(([date, availability]) => {
    const events = [];
    
    if (!availability.am) {
      events.push({
        id: `unavailable-am-${date}`,
        start: `${date}T00:00:00`,
        end: `${date}T12:00:00`,
        display: 'background',
        backgroundColor: '#f3f4f6',
        extendedProps: {
          isUnavailable: true,
          period: 'am'
        }
      });
    }
    
    if (!availability.pm) {
      events.push({
        id: `unavailable-pm-${date}`,
        start: `${date}T12:00:00`,
        end: `${date}T23:59:59`,
        display: 'background',
        backgroundColor: '#f3f4f6',
        extendedProps: {
          isUnavailable: true,
          period: 'pm'
        }
      });
    }
    
    return events;
  });

  const allCalendarEvents = [...calendarEvents, ...holidayEvents, ...availabilityEvents];

  const getEventTypeLabel = (eventType: string, status?: string): string => {
    switch (eventType) {
      case "requestedLeave":
        switch (status) {
          case "approved":
            return t('calendar.approvedHoliday');
          case "denied":
            return t('calendar.deniedHoliday');
          case "pending":
            return t('calendar.pendingHoliday');
          default:
            return t('calendar.requestedLeave');
        }
      case "requestedDesiderata":
        return t('calendar.requestedDesiderata');
      case "requestedPeriod":
        return t('calendar.requestedPeriod');
      default:
        return eventType
          .replace(/([A-Z])/g, " $1")
          .replace(/^./, (str) => str.toUpperCase());
    }
  };

  const getTextColor = (backgroundColor: string): string => {
    // Simple contrast calculation
    const hex = backgroundColor.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return brightness > 128 ? '#000000' : '#ffffff';
  };

  const handleDateClick = useCallback((info: any) => {
    setSelectedDate(info.date);
    setSelectedEvent(null);
    setShowModal(true);
  }, []);

  const handleEventClick = useCallback((info: any) => {
    const originalEvent = info.event.extendedProps.originalEvent;
    if (originalEvent && !info.event.extendedProps.isHoliday) {
      setSelectedEvent(originalEvent);
      setSelectedDate(info.event.start);
      setShowModal(true);
    }
  }, []);

  const handleCreateEvent = async (eventData: {
    title: string;
    description: string;
    date: string;
    endDate?: string;
    type: string;
    userId?: string;
    amSelected?: boolean;
    pmSelected?: boolean;
  }) => {
    // Implementation will be handled by existing event creation logic
    // This is just the interface for the modal
  };

  const handleGoToToday = () => {
    const calendarApi = calendarRef.current?.getApi();
    if (calendarApi) {
      calendarApi.today();
    }
  };

  return (
    <div className="max-w-7xl mx-auto px-2 sm:px-2 lg:px-4 py-4" data-tsx-id="calendar">
      <ConnectionStatus />
      
      <div className="flex justify-between items-center mb-4">
        <div className="flex items-center space-x-4">
          <button
            onClick={handleGoToToday}
            className="flex items-center px-3 py-2 space-x-2 text-sm font-medium text-blue-600 hover:bg-blue-50 rounded-md border border-blue-200"
            title={t('calendar.goToToday')}
          >
            <CalendarIcon className="w-4 h-4" />
            <span>{t('common.today')}</span>
          </button>
        </div>
      </div>

      <div className="bg-white rounded-lg shadow overflow-hidden">
        <FullCalendar
          ref={calendarRef}
          plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin]}
          initialView="dayGridMonth"
          headerToolbar={{
            left: 'prev,next',
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay'
          }}
          events={allCalendarEvents}
          dateClick={handleDateClick}
          eventClick={handleEventClick}
          selectable={true}
          selectMirror={true}
          dayMaxEvents={true}
          weekends={true}
          height="auto"
          locale={t('common.language')}
          firstDay={currentUser?.app?.weekStartsOn === "Sunday" ? 0 : 1}
          eventDisplay="block"
          displayEventTime={false}
          eventClassNames={(arg) => {
            const event = arg.event;
            const classes = ['fc-event-custom'];
            
            if (event.extendedProps.isHoliday) {
              classes.push('fc-event-holiday');
            }
            
            if (event.extendedProps.status === 'pending') {
              classes.push('fc-event-pending');
            } else if (event.extendedProps.status === 'approved') {
              classes.push('fc-event-approved');
            } else if (event.extendedProps.status === 'denied') {
              classes.push('fc-event-denied');
            }
            
            return classes;
          }}
          eventContent={(arg) => {
            const event = arg.event;
            const isMultiDay = event.end && event.start && 
              format(event.start, 'yyyy-MM-dd') !== format(new Date(event.end.getTime() - 1), 'yyyy-MM-dd');
            
            return (
              <div className="fc-event-main-frame">
                <div className="fc-event-title-container">
                  <div className="fc-event-title fc-sticky">
                    {event.title}
                    {isMultiDay && (
                      <span className="ml-1 text-xs opacity-75">
                        ({Math.ceil((event.end!.getTime() - event.start!.getTime()) / (1000 * 60 * 60 * 24))}d)
                      </span>
                    )}
                  </div>
                </div>
              </div>
            );
          }}
          dayCellContent={(arg) => {
            const availability = availabilityData[format(arg.date, 'yyyy-MM-dd')];
            const isWeekend = arg.date.getDay() === 0 || arg.date.getDay() === 6;
            
            return (
              <div className="fc-daygrid-day-number relative">
                {arg.dayNumberText}
                {!isLoadingAvailability && !isWeekend && availability && (
                  <div className="absolute inset-0 pointer-events-none">
                    {!availability.am && (
                      <div className="absolute inset-x-0 top-0 h-1/2 bg-gray-200 opacity-30" />
                    )}
                    {!availability.pm && (
                      <div className="absolute inset-x-0 bottom-0 h-1/2 bg-gray-200 opacity-30" />
                    )}
                  </div>
                )}
              </div>
            );
          }}
        />
      </div>

      <SettingsPanel />

      {showModal && selectedDate && (
        <EventModal
          date={selectedDate}
          endDate={null}
          event={selectedEvent}
          onClose={() => {
            setShowModal(false);
            setSelectedDate(null);
            setSelectedEvent(null);
          }}
          onSubmit={handleCreateEvent}
        />
      )}
    </div>
  );
}